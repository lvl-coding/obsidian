使用场景：通过函数模板调用另外一个函数，如：
 
template<typename F,typename T, typename U>  
void tempFun(F f, T && t1, U && t2)  
{  
f(t1, t2);  
}  
我们已经知道模板中使用万能引用是有益的，这样既能接收左值也能接收右值。但对于函数内部来说不管接收的是左值还是右值，模板函数内部对于形参都是左值(T && t1=var, t1本身是左值)。
 
此时如果f函数的第一个参数需要右值，我们必须这样调用:f(std::move(t1), t2);
 
但模板是通用的，我们不能直接用std::move()写死，这样就不能调用接收左值的函数了。
 
c++标准提供std::forward<>模板类来保持参数的原有类型，代码如下：
 
template<typename F,typename T, typename U>  
void tempFun(F f, T && t1, U && t2)  
{  
f(std::forward<T>(t1), std::forword<U>(t2));  
}  
这样传过来的参数t1、t2的类型被直接转发到函数f()中去，称为完美转发。
 
这样传递左值还是右值就有调用tempFun()函数参数的调用者来确定了。
 
完美应该把以上模板作为范例，即模板类型参数都用T&&格式的万能引用，需要调用函数的时候，参数都用std::forward<>()来进行传递。
 
所谓完美转发：无论目的调用函数需要哪种类型的参数都可以正确调用到我们想要的那个函数里。
 
根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值