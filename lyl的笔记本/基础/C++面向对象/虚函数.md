【C++要笑着学】虚函数表(VBTL) | 观察虚表指针 | 运行时决议与编译时决议 | 动态绑定与静态绑定 | 静态多态与动态多态 | 单继承与多继承关系的虚表
 > 来自 <[https://blog.csdn.net/weixin_50502862/article/details/126570193](https://blog.csdn.net/weixin_50502862/article/details/126570193)>   
 
 1. 虚函数表是一个存储虚函数地址的数组，以NULL结尾。虚表vftable在编译阶段生成，对象内存空间开辟以后，写入对象中的vfptr，然后调用构造函数。虚表在构造函数之前写入
2. 所谓的虚表的二次写入指的是在继承关系中，派生类对象要调用两次构造函数，一次是基类的，另外一次是自己的，因此虚表要写入两次。

- 虚表存储在数据段上。  
- 普通函数不能为虚函数  
- 构造函数不能为虚函数  
- 内联成员函数不能为虚函数  
- 静态成员函数不能为虚函数  
- 友元函数不能为虚函数

 # QA 
1. 构造（析构）函数中调用虚方法？
	不要这样操作，语法没问题。但是派生类对象构造（析构）期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类型，进入基类的析构函数时同样如此。

2. 纯虚函数
	纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。声明了纯虚函数的类是一个抽象类
	类中含有纯虚函数时，其vtable不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。

## 不能虚构造，要虚析构
1. 虚析构：将可能会被继承的父类的析构函数设为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构
	1.  用派生类指针指向派生类实例，析构的时候不管基类析构函数是不是虚函数，都会正常析构
    2. 用基类类型指针指向派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。如果没有虚函数的动态绑定功能，就只依据指针的类型来进行调用，而不是根据指针绑定的对象。
2. 默认的析构函数不是虚函数，因为虚函数需要额外的虚函数表和虚表指针，占用额外内存。
3. 不能虚构造：
       1. 虚函数对应一个vtale，这个表的地址是存储在对象的内存空间的。如果构造函数设置为虚函数，就需要到vtable中调用，可是对象还没有实例化，没有内存分配空间。
    2. 虚函数的作用在于通过父类的指针或引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是创建对象时自动调用的