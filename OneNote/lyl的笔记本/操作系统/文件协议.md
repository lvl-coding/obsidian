![Exported image](Exported%20image%2020250319160519-0.png)

Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。

- 索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。
- 目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，**目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存**
 
虚拟文件系统  
文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。

![Exported image](Exported%20image%2020250319160520-1.png) ![Exported image](Exported%20image%2020250319160521-2.png)

我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统维护一个打开文件表，文件表里的每一项代表「文件描述符」，所以说文件描述符是打开文件的标识。  
操作系统在打开文件表中维护着打开文件的状态和信息：

![Exported image](Exported%20image%2020250319160522-3.png)  

**系统级的打开文件描述符表：**

- 文件指针：当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；
- 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；
- 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；
- 访问权限：打开文件时的标识（open()的flags参数），文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式），每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；
- 与信号驱动相关的设置
- 对该文件i-node对象的引用，即i-node 表指针
 
**文件系统的****i-node****表：**

- 文件类型（例如：常规文件、套接字或FIFO）和访问权限
- 一个指针，指向该文件所持有的锁列表
- 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳

 **1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件**  
    2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。  
    3. 要获取和修改打开的文件标志（例如：O_APPEND、O_NONBLOCK和O_ASYNC），可执行fcntl()的F_GETFL和F_SETFL操作，其对作用域的约束与上一条颇为类似。  
    4. 文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
 
I/O 是分为两个过程的：  
数据准备的过程  
数据从内核空间拷贝到用户进程缓冲区的过程  
[https://blog.csdn.net/weixin_43408374/article/details/104770835](https://blog.csdn.net/weixin_43408374/article/details/104770835) #important  
[https://blog.csdn.net/u014426028/article/details/105809411](https://blog.csdn.net/u014426028/article/details/105809411)  
==文件操作与锁==  
==当多个进程====/====线程对同一个文件发生写操作的时候会发生什么？如果写的是文件的同一个位置呢？==  
==首先====write(2)====调用不是原子操作。当多个====write(2)====操作对一个文件的同一部分发起写操作的时候，情况实际上和多个线程访问共享的变量没有什么区别。按照不同的逻辑执行流，会有很多种可能的结果。也许大多数情况下符合预期，但是本质上这样的代码是不可靠的。==  
==特别的：文件操作中有两个操作是内核保证原子的，分别是====open(2)====调用的====O_CREAT====和====O_APPEND====这两个====flag====属性。== #important  
==Linux====下的文件锁有两种，分别是====flock(2)====的方式和====fcntl(2)====的方式，前者源于====BSD====，后者源于====System V====，各有限制和应用场景。==

![](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)

Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。

- 索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。
- 目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存

虚拟文件系统

文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。

![](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

![](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png)

我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统维护一个打开文件表，文件表里的每一项代表「文件描述符」，所以说文件描述符是打开文件的标识。

操作系统在打开文件表中维护着打开文件的状态和信息：

![](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

系统级的打开文件描述符表：

- 文件指针：当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；
- 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；
- 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；
- 访问权限：打开文件时的标识（open()的flags参数），文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式），每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；
- 与信号驱动相关的设置
- 对该文件i-node对象的引用，即i-node 表指针

文件系统的i-node表：

- 文件类型（例如：常规文件、套接字或FIFO）和访问权限
- 一个指针，指向该文件所持有的锁列表
- 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳

 1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件

    2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。

    3. 要获取和修改打开的文件标志（例如：O_APPEND、O_NONBLOCK和O_ASYNC），可执行fcntl()的F_GETFL和F_SETFL操作，其对作用域的约束与上一条颇为类似。

    4. 文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符

I/O 是分为两个过程的：

数据准备的过程

数据从内核空间拷贝到用户进程缓冲区的过程

![重要](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png) [https://blog.csdn.net/weixin_43408374/article/details/104770835](https://blog.csdn.net/weixin_43408374/article/details/104770835)

[https://blog.csdn.net/u014426028/article/details/105809411](https://blog.csdn.net/u014426028/article/details/105809411)

文件操作与锁

当多个进程/线程对同一个文件发生写操作的时候会发生什么？如果写的是文件的同一个位置呢？

首先write(2)调用不是原子操作。当多个write(2)操作对一个文件的同一部分发起写操作的时候，情况实际上和多个线程访问共享的变量没有什么区别。按照不同的逻辑执行流，会有很多种可能的结果。也许大多数情况下符合预期，但是本质上这样的代码是不可靠的。

![重要](file:///C:/Users/lyl/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png) 特别的：文件操作中有两个操作是内核保证原子的，分别是open(2)调用的O_CREAT和O_APPEND这两个flag属性。

Linux下的文件锁有两种，分别是flock(2)的方式和fcntl(2)的方式，前者源于BSD，后者源于System V，各有限制和应用场景。