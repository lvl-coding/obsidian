由容器、算法、迭代器、仿函数、适配器、空间配制器组成  
顺序容器：

1. vector：动态数组，元素在内存中连续存放，随机读取能在常数时间内完成，在尾端增删元素性能比较好，有保留内存只初始化成默认值。， 减少大小后内存也不会释放。当空间不足时还需要进行扩容。如果集合已满，在新增数据的时候，就要分配一块更大的内存，倍放将原来的数据复制过来，释放之前的内存，在插入新增的元素。new_capacity = max ( old_capacity * 2, n + old_capacity )
2. deque：双向队列，元素在多块内存中连续存放，随机读取能在常数时间内完成，仅次于vector，在两端增删元素具有较佳的性能
3. list：双向链表：元素在内存中不连续存放。在任何位置增删元素都能在常数时间完成，不支持随机存取。

关联式容器：元素是排序的，插入任何元素都按相应的排序规则来确定其位置；在查找时具有良好性能。通常以平衡二叉树实现。

1. set/multiset
2. map/multimap

容器适配器：stack，queue，priority_queue  
map实现原理：map内部实现了一个红黑树，具有自动排序的功能  
hashtable散列表采用了函数映射思想，记录的存储位置与记录的关键字关联起来  
unordered_map、unordered_set、unordered_multimap、 unordered_multiset采用哈希表实现  
空间配置器：一个程序包含数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。空间配置器是用来实现内存空间分配的工具。每一种容器的空间分配都是通过空间分配器实现的  
C++ STL空间配置器实现
 
很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。
 
内存配置操作: 通过alloc::allocate()实现 内存释放操作: 通过alloc::deallocate()实现 对象构造操作: 通过::construct()实现 对象释放操作: 通过::destroy()实现
 
关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。
 
capacity指容器能容纳的最大的元素的个数  
size指容器中实际的元素的个数  
resize既分配了空间，也创建了对象，一个形参表示大小，一个表示初始值  
reserve表示容器预留空间，但没有真正创建对象，只有一个表示大小的参数
 
容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题