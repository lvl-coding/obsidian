实现原型 #important  
//拷贝构造函数，无需检验参数的有效性  
String::String(const String &rhs)  
{  
m_data = new char[strlen(rhs.m_data) + 1];  
strcpy(m_data, rhs.m_data);  
}
 
拷贝构造函数是一种特殊构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。  
当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用拷贝构造函数。  
为啥**形参必须是对该类型的引用**呢？试想一下，假如形参是该类的一个实例，由于是传值参数，我们把形参复制到实参会调用拷贝构造函数，如果允许拷贝构造函数传值，就会在拷贝构造函数内调用拷贝构造函数，从而形成无休止的递归调用导致栈溢出。 #important
 
类String 拷贝构造函数与普通构造函数的区别是：在函数入口处无需与 NULL 进行比较，这是因为“引用”不可能是NULL，而“指针”可以为NULL。（这是引用与指针的一个重要区别）。然后需要注意的就是深复制了。