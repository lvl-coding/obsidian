- 互斥锁：mutex，用于在保证在任何时刻，都只有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。  
- 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。  
- 自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提升效率。但如果加锁时间过长，则会非常浪费cpu资源。  
- RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销教大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高  [# 深入理解RCU|核心原理]([深入理解RCU|核心原理-CSDN博客](https://blog.csdn.net/lianhunqianr1/article/details/118215624))
# QA
1. 互斥锁和读写锁的区别：
	1. 读写锁区分读者和写者，而互斥锁不区分
	2. 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间只允许一个写者，但是允许多个读者同时读对象。

2. 死锁
	所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。  
	产生死锁的四个必要条件
	1. 互斥条件：一个资源每次只能被一个进程使用
	2. 请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放。
	3. 不可剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
	4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
 
 3. 读写锁c++实现，一个互斥锁和两个条件变量：
	1. 阻塞获取读锁：
		获取锁，如果有已经有写锁或者写等待，读等待+1后，阻塞并释放锁。唤醒并没有上述写操作后，读等待-1，并当前读+1，最终释放阻塞前获取的锁
	2. 尝试获取读锁，出错立即返回
		获取锁，如果有已经有写锁或者写等待，解锁并且返回。否则读操作加一，解锁返回
	3. 阻塞获取写锁
		获取锁，如果当前不为空闲，则写等待=1，阻塞并释放锁。唤醒并无锁后，写等待-1，写上锁。最终释放阻塞前获取的锁
	4. 尝试获取写锁，出错立即返回
		获取锁，如果当前不为空闲，解锁并且返回。否则置为写状态，解锁返回
	5. 释放写锁或读锁
		获取锁，如果当前有读锁，读锁-1，如果有写锁，则释放，否则出错。有写等待，当前空闲，则唤醒一个写等待。如果有读等待，唤醒所有读等待。