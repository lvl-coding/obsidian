# 凡是能够取地址的可以称之为左值，反之称之为右值  
-  非const左值引用只能绑定到非const左值  
- const左值引用可绑定到const左值、非const左值、const右值、非const右值；  
- 非const右值引用只能绑定到非const右值，但不适用于函数模板的形参；  
- const右值引用可绑定到const右值和非const右值，它没有现实意义（毕竟右值引用的初衷在于移动语义，而移动就意味着修改）

# 万能引用与完美转发

## stdmove与stdforward
- std::move将左值转换为右值引用，从而方便的使用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。  
- 右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。  
### 完美转发（Perfect Forwarding）
是指在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中提供了这样的一个函数std::forward，它是为转发而生的，不管参数是T&&这种未定的引用还是明确的左值引用或者右值引用，它会按照参数本来的类型转发。

- 使用场景：通过函数模板调用另外一个函数，如：
```c++
template<typename F,typename T, typename U>  
void tempFun(F f, T && t1, U && t2)  
{  
	f(t1, t2);  
}  
```
我们已经知道模板中使用万能引用是有益的，这样既能接收左值也能接收右值。但对于函数内部来说不管接收的是左值还是右值，模板函数内部对于形参都是左值(`T && t1=var`, t1本身是左值)。
 此时如果f函数的第一个参数需要右值，我们必须这样调用:`f(std::move(t1), t2)`;
 但模板是通用的，我们不能直接用std::move()写死，这样就不能调用接收左值的函数了。
 c++标准提供`std::forward<>`模板类来保持参数的原有类型，代码如下：
```cpp
template<typename F,typename T, typename U>  
void tempFun(F f, T && t1, U && t2)  
{  
	f(std::forward<T>(t1), std::forword<U>(t2));  
}  
```
这样传过来的参数`t1`、`t2`的类型被直接转发到函数`f()`中去，称为**完美转发**。
 这样传递左值还是右值就有调用`tempFun()`函数参数的调用者来确定了。
 完美应该把以上模板作为范例，即模板类型参数都用T&&格式的万能引用，需要调用函数的时候，参数都用`std::forward<>()`来进行传递。
 所谓完美转发：无论目的调用函数需要哪种类型的参数都可以正确调用到我们想要的那个函数里。
 根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值
