互斥锁：mutex，用于在保证在任何时刻，都只有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。  
读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。  
自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提升效率。但如果加锁时间过长，则会非常浪费cpu资源。  
RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销教大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高  
[深入理解](https://blog.itpub.net/70041323/viewspace-3037091/#:~:text=RCU%20%28Read-Copy,Update%29%EF%BC%8C%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89%E5%B0%B1%E6%98%AF%E8%AF%BB-%E6%8B%B7%E8%B4%9D%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%85%B6%E5%8E%9F%E7%90%86%E5%91%BD%E5%90%8D%E7%9A%84%E3%80%82%20%E5%AF%B9%E4%BA%8E%E8%A2%ABRCU%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AF%BB%E8%80%85%E4%B8%8D%E9%9C%80%E8%A6%81%E8%8E%B7%E5%BE%97%E4%BB%BB%E4%BD%95%E9%94%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%AE%83%EF%BC%8C%E4%BD%86%E5%86%99%E8%80%85%E5%9C%A8%E8%AE%BF%E9%97%AE%E5%AE%83%E6%97%B6%E9%A6%96%E5%85%88%E6%8B%B7%E8%B4%9D%E4%B8%80%E4%B8%AA%E5%89%AF%E6%9C%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AF%B9%E5%89%AF%E6%9C%AC%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%8C%E6%9C%80%E5%90%8E%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%EF%BC%88callback%EF%BC%89%E6%9C%BA%E5%88%B6%E5%9C%A8%E9%80%82%E5%BD%93%E7%9A%84%E6%97%B6%E6%9C%BA%E6%8A%8A%E6%8C%87%E5%90%91%E5%8E%9F%E6%9D%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E9%92%88%E6%9B%BF%E6%8D%A2%E4%B8%BA%E6%96%B0%E7%9A%84%E8%A2%AB%E4%BF%AE%E6%94%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82%20%E8%BF%99%E4%B8%AA%E6%97%B6%E6%9C%BA%E5%B0%B1%E6%98%AF%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8%E8%AF%A5%E6%95%B0%E6%8D%AE%E7%9A%84CPU%E9%83%BD%E9%80%80%E5%87%BA%E5%AF%B9%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82)RCU|核心原理  
互斥锁和读写锁的区别：

1. 读写锁区分读者和写者，而互斥锁不区分
2. 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间只允许一个写者，但是允许多个读者同时读对象。
 
死锁  
所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。  
产生死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放。
3. 不可剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
 
读写锁c++实现，一个互斥锁和两个条件变量：

1. 阻塞获取读锁：

获取锁，如果有已经有写锁或者写等待，读等待+1后，阻塞并释放锁。唤醒并没有上述写操作后，读等待-1，并当前读+1，最终释放阻塞前获取的锁

3. 尝试获取读锁，出错立即返回

获取锁，如果有已经有写锁或者写等待，解锁并且返回。否则读操作加一，解锁返回

5. 阻塞获取写锁

获取锁，如果当前不为空闲，则写等待=1，阻塞并释放锁。唤醒并无锁后，写等待-1，写上锁。最终释放阻塞前获取的锁

7. 尝试获取写锁，出错立即返回

获取锁，如果当前不为空闲，解锁并且返回。否则置为写状态，解锁返回

9. 释放写锁或读锁

获取锁，如果当前有读锁，读锁-1，如果有写锁，则释放，否则出错。有写等待，当前空闲，则唤醒一个写等待。如果有读等待，唤醒所有读等待。